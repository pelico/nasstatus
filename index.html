<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NAS 实时状态监控</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
        }
        .container {
            max-width: 800px;
            width: 100%;
            background: #1e1e1e;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        h1 {
            text-align: center;
            color: #bb86fc;
            margin-bottom: 30px;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .metric-card {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-label {
            font-size: 1em;
            color: #a0a0a0;
            margin-bottom: 10px;
            display: block;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #03dac6;
            font-family: "Courier New", Courier, monospace;
        }
        .metric-subvalue {
            font-size: 0.9em;
            color: #a0a0a0;
            margin-top: 5px;
        }
        #status-footer {
            text-align: center;
            margin-top: 30px;
            font-size: 0.8em;
            color: #666;
        }
        .error { color: #cf6679; }
    </style>
</head>
<body>
    <div class="container">
        <h1>NAS 实时状态监控</h1>
        <div class="grid-container">
            <div class="metric-card">
                <span class="metric-label">CPU 使用率</span>
                <div class="metric-value" id="cpu-usage">-- %</div>
            </div>
            <div class="metric-card">
                <span class="metric-label">内存使用率</span>
                <div class="metric-value" id="mem-usage">-- %</div>
                <div class="metric-subvalue" id="mem-details">-- / -- MB</div>
            </div>
            <div class="metric-card">
                <span class="metric-label">下载速度</span>
                <div class="metric-value" id="net-down">-- MB/s</div>
            </div>
            <div class="metric-card">
                <span class="metric-label">上传速度</span>
                <div class="metric-value" id="net-up">-- MB/s</div>
            </div>
            <div class="metric-card">
                <span class="metric-label">总下载量</span>
                <div class="metric-value" id="net-total-down">-- GB</div>
            </div>
             <div class="metric-card">
                <span class="metric-label">总上传量</span>
                <div class="metric-value" id="net-total-up">-- GB</div>
            </div>
        </div>
        <div id="status-footer">
            <span id="status-text">正在连接...</span>
            <span id="error-text" class="error"></span>
        </div>
    </div>

    <script>
        // ##################################################################
        // #                       !!! 用户配置区 !!!                       #
        // ##################################################################

        // 1. 将下面的URL替换为您的Cloudflare Worker地址
        const WORKER_URL = 'https://nas-hook.111312.xyz';

        // 2. 指定您想监控的网络接口名称 (可以是一个或多个)
        //    根据您提供的数据，'eth0' 和 'wlan0' 是主要接口
        const TARGET_INTERFACES = ['eth0', 'wlan0'];

        // ##################################################################
        
        // 用于存储上一次获取的数据，以便计算速率
        let previousCpuData = null;
        let previousNetData = null;
        let lastFetchTime = null;

        // --- 辅助函数 ---
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        function formatSpeed(bytesPerSecond, decimals = 2) {
             if (bytesPerSecond < 1) return '0 B/s';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s', 'TB/s'];
            const i = Math.floor(Math.log(bytesPerSecond) / Math.log(k));
            return parseFloat((bytesPerSecond / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // --- 数据解析与计算 ---
        function parseMetrics(text) {
            const metrics = {
                cpu: { total: 0, idle: 0 },
                memory: { total: 0, available: 0 },
                network: { received: 0, transmitted: 0 }
            };

            const lines = text.split('\n');
            for (const line of lines) {
                if (line.startsWith('#')) continue;

                // CPU
                if (line.startsWith('node_cpu_seconds_total')) {
                    const value = parseFloat(line.split(' ')[1]);
                    metrics.cpu.total += value;
                    if (line.includes('mode="idle"')) {
                        metrics.cpu.idle += value;
                    }
                }
                // Memory
                else if (line.startsWith('node_memory_MemTotal_bytes')) {
                    metrics.memory.total = parseFloat(line.split(' ')[1]);
                }
                else if (line.startsWith('node_memory_MemAvailable_bytes')) {
                    metrics.memory.available = parseFloat(line.split(' ')[1]);
                }
                // Network
                else if (line.startsWith('node_network_receive_bytes_total') || line.startsWith('node_network_transmit_bytes_total')) {
                    const isReceive = line.startsWith('node_network_receive_bytes_total');
                    const interfaceMatch = line.match(/device="([^"]+)"/);
                    if (interfaceMatch && TARGET_INTERFACES.includes(interfaceMatch[1])) {
                        const value = parseFloat(line.split(' ')[1]);
                        if (isReceive) {
                            metrics.network.received += value;
                        } else {
                            metrics.network.transmitted += value;
                        }
                    }
                }
            }
            return metrics;
        }

        // --- 主函数 ---
        async function fetchData() {
            const statusText = document.getElementById('status-text');
            const errorText = document.getElementById('error-text');
            
            try {
                const response = await fetch(WORKER_URL);
                if (!response.ok) {
                    throw new Error(`请求失败: ${response.status} ${response.statusText}`);
                }
                const text = await response.text();
                const now = Date.now();
                
                const currentMetrics = parseMetrics(text);
                
                // --- 计算 CPU ---
                if (previousCpuData) {
                    const totalDiff = currentMetrics.cpu.total - previousCpuData.total;
                    const idleDiff = currentMetrics.cpu.idle - previousCpuData.idle;
                    const usage = 100 * (1 - (idleDiff / totalDiff));
                    document.getElementById('cpu-usage').textContent = `${usage.toFixed(1)} %`;
                }
                
                // --- 计算内存 ---
                const memTotalMB = (currentMetrics.memory.total / 1024 / 1024);
                const memAvailableMB = (currentMetrics.memory.available / 1024 / 1024);
                const memUsedMB = memTotalMB - memAvailableMB;
                const memUsagePercent = (memUsedMB / memTotalMB) * 100;
                document.getElementById('mem-usage').textContent = `${memUsagePercent.toFixed(1)} %`;
                document.getElementById('mem-details').textContent = `${memUsedMB.toFixed(0)} / ${memTotalMB.toFixed(0)} MB`;
                
                // --- 计算网络 ---
                if (previousNetData && lastFetchTime) {
                    const timeDelta = (now - lastFetchTime) / 1000; // in seconds
                    
                    const downBytesDiff = currentMetrics.network.received - previousNetData.received;
                    const upBytesDiff = currentMetrics.network.transmitted - previousNetData.transmitted;

                    const downSpeed = downBytesDiff / timeDelta;
                    const upSpeed = upBytesDiff / timeDelta;

                    document.getElementById('net-down').textContent = formatSpeed(downSpeed);
                    document.getElementById('net-up').textContent = formatSpeed(upSpeed);
                }

                document.getElementById('net-total-down').textContent = formatBytes(currentMetrics.network.received, 1);
                document.getElementById('net-total-up').textContent = formatBytes(currentMetrics.network.transmitted, 1);

                // 更新状态以备下次计算
                previousCpuData = currentMetrics.cpu;
                previousNetData = currentMetrics.network;
                lastFetchTime = now;
                
                statusText.textContent = `上次更新: ${new Date().toLocaleTimeString()}`;
                errorText.textContent = '';
            } catch (error) {
                console.error('获取NAS状态失败:', error);
                errorText.textContent = `错误: ${error.message}`;
            }
        }

        // 首次加载，并设置每5秒刷新一次
        fetchData();
        setInterval(fetchData, 5000);
    </script>
</body>
</html>
